// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')

module.exports = {
  detectReentrancy: (parseTree) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, '$..[?(@.type=="FunctionCall")]')
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, '$..[?(@.type=="BinaryOperation" && (@.operator=="=" || @.operator=="+=" || @.operator=="-="))]')
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree) => {
    let outdatedPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
      outdatedPragmaDirective = pragmaDirective[0]
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree) => {
    let floatingPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective = pragmaDirective[0]
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, '$..[?(@.memberName=="transfer" || @.memberName=="send")]')
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  },

  detectUncheckedCallReturnValue: (parseTree) => {
    // Vulnerability patterns for Unchecked Call Return Value
    const uncheckedStatements = '$..statements[?(@.type != "IfStatement" && @.type != "ReturnStatement" && ' +
        '@.type != "VariableDeclarationStatement")]'
    const lowLevelFunctionCalls = '$..expression[?(@.type != "FunctionCall" && (@.memberName == "call" || @.memberName == "send" || ' +
        '@.memberName == "delegatecall" || @.memberName == "callcode"))]'

    // JSON Queries for pattern matching
    const q1 = JSONPath({ json: parseTree, path: uncheckedStatements, resultType: 'value' })
    const q2 = JSONPath({ json: q1, path: lowLevelFunctionCalls, resultType: 'value' })

    // Return if vulnerability is detected or not
    return q2.length > 0
  },

  detectTXOrigin: (parseTree) => {
    //Patterns to detect Tx.Origin
    const TXOriginPattern = [
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.left.expression.name == "tx") && (@.left.memberName == "origin"))]',
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.right.expression.name == "tx") && (@.right.memberName == "origin"))]',
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.left.name =="owner") && (@.expression.right.memberName == "origin") && (@.expression.right.expression.name == "tx"))]'
    ]

    var detected_pattern = []

    //check JSON with all TXOriginPattern, if any pattern is matched, we will return value 1, else return 0
    for(var i=0; i<TXOriginPattern.length;i++)
    {
        const returnvalue = JSONPath({ json: parseTree, path: TXOriginPattern[i], resultType: 'value' })
        if(returnvalue.length != 0)
        {
            detected_pattern = returnvalue
            return 1
        }
    }
    return 0
  },

  detectUnderFlow: (parseTree) => {

    //Check Safemath Library is available in smart contract. Because, Safemath library is able to handle boundary limits of the variable. If it is mentioned in smart contract, then vulnerability is not present in solidity code
    const safemath_statement = JSONPath({ json: parseTree, path: '$..children[?(@.type == "ContractDefinition")].subNodes[?( (@.type == "UsingForDeclaration") && (@.typeName.name =~ "/.*unit/i") && (@.libraryName == "SafeMath") )]', resultType: 'value' })
    if(safemath_statement.length != 0)
    {
        //No vulnerability
        return 0
    }
    else
    {
        const loop_condition = JSONPath({ json: parseTree, path: '$..subNodes[?((@.type == "FunctionDefinition") && ((@.body.statements[0].type == "WhileStatement") || (@.body.statements[0].type == "ForStatement")) )].body', resultType: 'value' })
        if(loop_condition.length != 0)
        {
            const check_inside_loop = JSONPath({ json: loop_condition, path: '$..statements[?( ((@.type == "WhileStatement") && (@.condition.operator == ">=") && (@.condition.right.number == "0") && (@.body.statements[0].expression.operator == "--") && (@.condition.left.name == @.body.statements[0].expression.subExpression.name) ) || ((@.type == "ForStatement") && (@.conditionExpression.operator == ">=") && (@.conditionExpression.right.number=="0") && (@.loopExpression.expression.operator == "--") && (@.conditionExpression.left.name == @.loopExpression.expression.subExpression.name) ) )]', resultType: 'value' })
            if(check_inside_loop != 0)
            {
                //No vulnerability
                return 0
            }
        }
        const if_condition = JSONPath({ json: parseTree, path: '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?( (@.type == "IfStatement") && (@.condition.operator == ">=") && (@.condition.right.number == "0") && (@.trueBody.statements[0].expression.right.operator  == "-") && ( ((@.trueBody.statements[0].expression.right.type == "UnaryOperation") && (@.trueBody.statements[0].expression.left.name  == @.condition.left.left.name)) || ( (@.trueBody.statements[0].expression.right.operator  == "-") && (@.trueBody.statements[0].expression.right.left.name  == @.condition.left.left.name) )  )  )]', resultType: 'value' })
        if(if_condition != 0)
        {
            //No vulnerability
            return 0
        }
        const require_statement = JSONPath({ json: parseTree, path: '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "FunctionCall") && (@.expression.expression.name == "require") )].expression', resultType: 'value' })
        if(require_statement.length != 0)
        {
            const check_require = JSONPath({ json: require_statement, path: '$..arguments[?( (@.operator == ">=") && (@.right.number == "0") )]', resultType: 'value' })
            if(check_require.length != 0)
            {
                //No vulnerability
                return 0
            }
        }
        return 1
    }
  },

  detectOverFlow: (parseTree) => {

    const safemath_statement = JSONPath({ json: parseTree, path: '$..children[?(@.type == "ContractDefinition")].subNodes[?((@.type == "UsingForDeclaration") && (@.typeName.name =~ "/.*unit/i") && (@.libraryName == "SafeMath"))]', resultType: 'value' })
    if(safemath_statement.length != 0)
    {
        //No vulnerability
        return 0
    }
    else
    {
        const if_condition_1 = JSONPath({ json: parseTree, path: '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "IfStatement") && ((@.condition.operator == "<") || (@.condition.operator == "<=")) && (@.condition.left.components[0].operator == "+") )]', resultType: 'value' })
        if(if_condition_1.length != 0)
        {
            const check_inside_if = JSONPath({ json: if_condition_1, path: '$..right.components[?( ((@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ((@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1")) )]', resultType: 'value' })
            if(check_inside_if.length != 0)
            {
                //No vulnerability
                return 0
            }
        }
        const if_condition_2 = JSONPath({ json: parseTree, path: '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "IfStatement") && ((@.condition.operator == "<") || (@.condition.operator == "<=")) && (@.condition.left.components[0].operator == "+") )]', resultType: 'value' })
        if(if_condition_2.length != 0)
        {
            const check_inside_if = JSONPath({ json: if_condition_2, path:'$..right.number', resultType: 'value' })
            if(check_inside_if <= 256 || check_inside_if <= 65536 || check_inside_if <= 4294967296 || check_inside_if <= 18446744073709551615 || check_inside_if <= 170141183460469231731687303715884105728)
            {
                //No vulnerability
                return 0
            }
        }
        const require_statement = JSONPath({json: parseTree, path: '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "FunctionCall") && (@.expression.expression.name == "require") )]', resultType: 'value'})
        if(require_statement.length != 0)
        {
            const check_require = JSONPath({json:require_statement, path:'$..arguments[?( ((@.operator == "<") || (@.operator == "<")) && ((@.right.number <= "256") || (@.right.number <= "65535")) && (@.left.operator == "+") )]', resultType: 'value'})
            if(check_require.length != 0)
            {
                //No vulnerability
                return 0
            }
        }
        const loop_condition = JSONPath({ json: parseTree, path: '$..subNodes[?((@.type == "FunctionDefinition") && ((@.body.statements[0].type == "WhileStatement") || (@.body.statements[0].type == "ForStatement")) )].body', resultType: 'value' })
        if(loop_condition.length != 0)
        {
            const check_inside_loop = JSONPath({ json: loop_condition, path: '$..statements[?( ((@.type == "WhileStatement") && (@.condition.operator == "<=") && ((@.condition.right.number <= "256") || (@.condition.right.number <= "65535")) && (@.body.statements[0].expression.operator == "++") && (@.condition.left.name == @.body.statements[0].expression.subExpression.name) ) || ((@.type == "ForStatement") && (@.conditionExpression.operator == "<=") && ((@.conditionExpression.right.number <="256") || (@.conditionExpression.right.number <="65535"))&& (@.loopExpression.expression.operator == "++") && (@.conditionExpression.left.name == @.loopExpression.expression.subExpression.name) ) )]', resultType: 'value' })
            if(check_inside_loop != 0)
            {
                //No vulnerability
                return 0
            }
        }
        return 1
    }
  }

}
