// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')

module.exports = {
  detectReentrancy: (parseTree) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, '$..[?(@.type=="FunctionCall")]')
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, '$..[?(@.type=="BinaryOperation" && (@.operator=="=" || @.operator=="+=" || @.operator=="-="))]')
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree) => {
    let outdatedPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
      outdatedPragmaDirective = pragmaDirective[0]
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree) => {
    let floatingPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective = pragmaDirective[0]
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, '$..[?(@.memberName=="transfer" || @.memberName=="send")]')
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  },

  detectUncheckedCallReturnValue: (parseTree) => {
    let uncheckedCallReturnValues = []
    // Vulnerability patterns for Unchecked Call Return Value
    const uncheckedStatements = '$..statements[?(@.type != "IfStatement" && @.type != "ReturnStatement" && ' +
        '@.type != "VariableDeclarationStatement")]'
    const lowLevelFunctionCalls = '$..expression[?(@.type != "FunctionCall" && (@.memberName == "call" || @.memberName == "send" || ' +
        '@.memberName == "delegatecall" || @.memberName == "callcode"))]'

    // JSON Queries for pattern matching
    const q1 = JSONPath({ json: parseTree, path: uncheckedStatements, resultType: 'value' })
    const q2 = JSONPath({ json: q1, path: lowLevelFunctionCalls, resultType: 'value' })
    uncheckedCallReturnValues = [q2.length > 0, q2]

    return uncheckedCallReturnValues
  },

  detectTXOrigin: (parseTree) => {
    //Patterns to detect Tx.Origin
    const TXOriginPattern = [
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.left.expression.name == "tx") && (@.left.memberName == "origin"))]',
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.right.expression.name == "tx") && (@.right.memberName == "origin"))]',
    '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.left.name =="owner") && (@.expression.right.memberName == "origin") && (@.expression.right.expression.name == "tx"))]'
    ]

    const detected_pattern = []

    //check JSON with all TXOriginPattern, if any pattern is matched, we will return value 1, else return 0
    for(var i=0; i<TXOriginPattern.length;i++)
    {
        const returnvalue = jsonpath.query(parseTree,TXOriginPattern[i])
        if(returnvalue.length != 0)
        {
            detected_pattern.push(returnvalue)
        }
    }
    //console.log(detected_pattern)
    if(detected_pattern.length > 0)
    {
        return [1, detected_pattern]
    }
    else
    {
        return [0,[]]
    }
  },

  detectUnderFlow: (parseTree) => {

    const detected_pattern = []

    //If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.right.operator == "-") )]')
    for(let i=0;i<statement.length;i++)
    {
        detected_pattern.push(statement[i])
    }

    //Now, we are considering scenario where our expression is mentioned in If statement, but not handled in If condition
    const if_statement_query = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "IfStatement")]')
    for(let i=0;i<if_statement_query.length;i++)
    {
        const if_statement = if_statement_query[i]
        if(if_statement.length != 0)
        {
            const check_variable_in_if_statement = jsonpath.query(if_statement,'$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "-") )].expression.right.left.name')

            const check_variable_in_if_condition = jsonpath.query(if_statement,'$..[?((@.type == "BinaryOperation") && (@.operator == ">=") && (@.right.number == "0"))].left.left.name')

            if( (check_variable_in_if_condition.length >= 0) && (check_variable_in_if_statement.length >= 0))
            {
                if(check_variable_in_if_statement[0] != check_variable_in_if_condition[0])
                {
                    const statement_in_if = jsonpath.query(if_statement,'$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "-") )].expression')
                    detected_pattern.push(statement_in_if)
                }
            }
            //console.log(detected_pattern)
        }
    }

    //Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const while_statement_query = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "WhileStatement")]')
    for(let i=0;i<while_statement_query.length;i++)
    {
        const while_statement = while_statement_query[i]
        if(while_statement.length != 0)
        {
            const check_variable_in_while_statement = jsonpath.query(while_statement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression.subExpression.name')
            const check_variable_in_while_condition = jsonpath.query(while_statement, '$..[?((@.type=="BinaryOperation") && (@.operator == ">=") && (@.right.number == "0") )].left.name')

            if( (check_variable_in_while_statement.length >= 0) && (check_variable_in_while_condition.length >= 0))
            {
                if(check_variable_in_while_statement[0] != check_variable_in_while_condition[0])
                {
                    const statement_in_while = jsonpath.query(while_statement,'$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression')
                    detected_pattern.push(statement_in_while)
                }
            }
        }
    }

    //Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const for_statement_query = jsonpath.query(parseTree,'$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ForStatement")]')
    for(let i=0;i<for_statement_query.length;i++)
    {
        const for_statement = for_statement_query[i]
        if(for_statement != 0)
        {
            const check_variable_in_for_statement = jsonpath.query(for_statement, '$..[?((@.type == "BinaryOperation") && (@.operator == ">=") && (@.right.number == "0") )].left.name')
            const check_variable_in_for_condition = jsonpath.query(for_statement, '$..[?((@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression.subExpression.name')
            if( (check_variable_in_for_statement.length >= 0) && (check_variable_in_for_condition.length >= 0))
            {
                if(check_variable_in_for_statement[0] != check_variable_in_for_condition[0])
                {
                    detected_pattern.push(for_statement)
                }
            }
        }
    }

    //console.log(detected_pattern)
    if(detected_pattern.length > 0)
    {
        return [1, detected_pattern]
    }
    else
    {
        return [0,[]]
    }
  },

  detectOverFlow: (parseTree) => {

    const detected_pattern = []

    //If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.right.operator == "+") )]')
    for(let i=0;i<statement.length;i++)
    {
        detected_pattern.push(statement[i])
    }

    //Now, we are considering scenario where our expression is mentioned in If statement, but not handled in If condition
    const if_statement_query = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "IfStatement")]')
    for(let i=0;i<if_statement_query.length;i++)
    {
        const if_statement = if_statement_query[i]
        if(if_statement.length != 0)
        {
            const check_variable_in_if_statement = jsonpath.query(if_statement,'$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "+") )].expression.right.left.name')
            const check_variable_in_if_condition = jsonpath.query(if_statement,'$..[?((@.type == "BinaryOperation") && (@.operator == "<"))].right.components[?( (@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ( (@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
            const check_variable_in_if_variable = jsonpath.query(if_statement, '$..[?((@.type == "BinaryOperation") && (@.operator == "<"))].left.components[?(@.type=="BinaryOperation")].left.name')

            if(check_variable_in_if_condition != 0)
            {
                if(check_variable_in_if_statement.length != 0 && check_variable_in_if_variable != 0)
                {
                    if(check_variable_in_if_statement[0] != check_variable_in_if_variable[0])
                    {
                        const statement_in_if = jsonpath.query(if_statement, '$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "+") )].expression')
                        detected_pattern.push(statement_in_if)
                    }
                }
            }
        }
    }

    //Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const while_statement_query = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "WhileStatement")]')
    for(let i=0;i<while_statement_query.length;i++)
    {
        const while_statement = while_statement_query[i]
        if(while_statement.length != 0)
        {
            const check_variable_in_while_statement = jsonpath.query(while_statement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression.subExpression.name')
            const check_variable_in_while_condition = jsonpath.query(while_statement, '$..[?((@.type=="BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].right.components[?((@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ( (@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
            const check_variable_in_while_variable = jsonpath.query(while_statement,'$..[?((@.type=="BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].left.name')

            if(check_variable_in_while_statement.length != 0 && check_variable_in_while_variable.length != 0)
            {
                if(check_variable_in_while_statement[0] != check_variable_in_while_variable[0])
                {
                    const statement_in_while = jsonpath.query(while_statement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression')
                    detected_pattern.push(statement_in_while)
                }
                else
                {
                    if(check_variable_in_while_condition == 0)
                    {
                        const statement_in_while = jsonpath.query(while_statement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression')
                        detected_pattern.push(statement_in_while)
                    }
                }
            }
        }
    }

    //Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const for_statement_query = jsonpath.query(parseTree,'$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ForStatement")]')
    for(let i=0;i<for_statement_query.length;i++)
    {
        const for_statement = for_statement_query[i]
        if(for_statement != 0)
        {
            const check_variable_in_for_statement = jsonpath.query(for_statement, '$..[?( (@.type == "BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].right.components[?( (@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ((@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
            const check_variable_in_for_variable = jsonpath.query(for_statement, '$..[?( (@.type == "BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].left.name')
            const check_variable_in_for_condition = jsonpath.query(for_statement, '$..loopExpression[?((@.type == "UnaryOperation") && (@.operator == "++") )].subExpression.name')
            if(check_variable_in_for_statement.length != 0 && check_variable_in_for_variable.length != 0 && check_variable_in_for_condition.length != 0)
            {
                if(check_variable_in_for_variable[0] != check_variable_in_for_condition[0])
                {
                    detected_pattern.push(for_statement)
                }
            }
        }
    }

    //console.log(detected_pattern)
    if(detected_pattern.length > 0)
    {
        return [1, detected_pattern]
    }
    else
    {
        return [0,[]]
    }

  }

}
